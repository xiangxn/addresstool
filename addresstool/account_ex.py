from hexbytes import (HexBytes)
from eth_utils.curried import (combomethod, hexstr_if_str, to_int)
from eth_account._utils.signing import (to_standard_signature_bytes, to_standard_v, hash_of_signed_transaction)
from web3.types import (RPCEndpoint, _Hash32, TxData)
from web3._utils.rpc_abi import (RPC, RPC_ABIS, abi_request_formatters)
from web3._utils.method_formatters import STANDARD_NORMALIZERS
from web3.method import (Method, default_root_munger)
from web3.middleware.formatting import construct_formatting_middleware
from typing import (Callable)
from web3.eth import Eth
from eth_account.account import Account
from eth_account._utils.transactions import (Transaction, vrs_from)

setattr(RPC, 'eth_getRawTransactionByHash', RPCEndpoint("eth_getRawTransactionByHash"))
RPC_ABIS['eth_getRawTransactionByHash'] = ['bytes']

my_abi_middleware = construct_formatting_middleware(request_formatters=abi_request_formatters(STANDARD_NORMALIZERS, RPC_ABIS))

get_raw_transaction: Method[Callable[[_Hash32], TxData]] = Method(RPC.eth_getRawTransactionByHash, mungers=[default_root_munger])

setattr(Eth, 'get_raw_transaction', get_raw_transaction)


# @combomethod
def _recover_hash_pk(self, message_hash, vrs=None, signature=None):
    hash_bytes = HexBytes(message_hash)
    if len(hash_bytes) != 32:
        raise ValueError("The message hash must be exactly 32-bytes")
    if vrs is not None:
        v, r, s = map(hexstr_if_str(to_int), vrs)
        v_standard = to_standard_v(v)
        signature_obj = self._keys.Signature(vrs=(v_standard, r, s))
    elif signature is not None:
        signature_bytes = HexBytes(signature)
        signature_bytes_standard = to_standard_signature_bytes(signature_bytes)
        signature_obj = self._keys.Signature(signature_bytes=signature_bytes_standard)
    else:
        raise TypeError("You must supply the vrs tuple or the signature bytes")
    pubkey = signature_obj.recover_public_key_from_msg_hash(hash_bytes)
    return pubkey


# @combomethod
def recoverHashPK(self, message_hash, vrs=None, signature=None):
    """
    Get the address of the account that signed the message with the given hash.
    You must specify exactly one of: vrs or signature

    .. CAUTION:: Deprecated for :meth:`~eth_account.account.Account.recover_message`.
        This method might be removed as early as v0.5

    :param message_hash: the hash of the message that you want to verify
    :type message_hash: hex str or bytes or int
    :param vrs: the three pieces generated by an elliptic curve signature
    :type vrs: tuple(v, r, s), each element is hex str, bytes or int
    :param signature: signature bytes concatenated as r+s+v
    :type signature: hex str or bytes or int
    :returns: address of signer, hex-encoded & checksummed
    :rtype: str
    """
    return self._recover_hash_pk(message_hash, vrs, signature)


def recover_transaction_pk(self, serialized_transaction):
    txn_bytes = HexBytes(serialized_transaction)
    txn = Transaction.from_bytes(txn_bytes)
    msg_hash = hash_of_signed_transaction(txn)
    return self._recover_hash_pk(msg_hash, vrs=vrs_from(txn))


setattr(Account, '_recover_hash_pk', _recover_hash_pk)
setattr(Account, 'recover_transaction_pk', recover_transaction_pk)
